/* eslint-disable @typescript-eslint/no-explicit-any */
import { PurchasesDTO, itemPurchaseDTO } from '../app/models/purchasesDTO';
import { Formik } from 'formik';
import React, { Component } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { TextInput, Button, Text, DefaultTheme } from 'react-native-paper';
import { connect, ConnectedProps } from 'react-redux';
import { setMessage } from '../store/actions/message';
import { SavePurchases, UpdatePurchases } from '../store/actions/purchases';
import { Market } from '../app/models/market';
import { LoadAllMarket } from '../store/actions/market';
import { LoadAllCategory } from '../store/actions/category';
import { LoadAllProduct } from '../store/actions/product';
import { AutoComplete } from './../components/AutoComplete/index';
import { ValueType } from 'react-native-dropdown-picker';
import { Product } from '../app/models/product';
import { Category } from '../app/models/category';
import formatMoney from './../app/util/MoneyFormat';
import totalFormat from './../app/util/TotalFormat';
import DatePicker from 'react-native-date-picker';
import Icon from 'react-native-vector-icons/AntDesign';
import { Purchases } from 'app/models/purchases';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { CommonActions } from '@react-navigation/native';

interface Props extends PropsFromRedux {
  navigation: {
    navigate: any;
    toggleDrawer: any;
    closeDrawer: any;
    openDrawer: any;
    dispatch: any;
  };
  route: {
    params: any;
  };
}

const initialValues = {
  purchases: {
    id: 0,
    marketId: 0,
    status: 'Entregue',
    date: new Date(),
    itemPurchaseDTOList: [
      {
        id: 0,
        quantity: 0,
        validaty: new Date(''),
        price: 0,
        productId: 0,
      },
    ] as itemPurchaseDTO[],
  } as PurchasesDTO,
};

const initialValuesItem = {
  itemPurchases: {
    id: 0,
    quantity: 0,
    validaty: new Date(''),
    price: 0,
    productId: 0,
  } as itemPurchaseDTO,
};

class PurchasesForm extends Component<Props> {
  state = {
    dateModal: false,
    validatyDateModal: false,
    productFilter: [] as Product[],
    itemPurchasesList: [] as itemPurchaseDTO[],
    ...initialValues,
    ...initialValuesItem,
  };

  componentDidMount = async () => {
    await this.props.loadAllMarket();
    await this.props.loadAllCategory();
    await this.props.loadAllProduct();

    if (typeof this.props.route.params?.purchases != 'undefined') {
      const purchases: Purchases = this.props.route.params.purchases;
      const purchasesDto = purchasesToPurchasesDTO(purchases);

      this.setState({
        ...this.state,
        purchases: purchasesDto,
        itemPurchasesList: purchasesDto.itemPurchaseDTOList,
      });
    } else {
      const newListStorage = JSON.parse(
        (await AsyncStorage.getItem('PurchasesList')) || '',
      );

      this.setState({
        ...this.state,
        purchases: {
          ...initialValues.purchases,
          itemPurchaseDTOList: newListStorage,
        },
        itemPurchasesList: newListStorage,
      });
    }
  };

  render() {
    return (
      <Formik
        initialValues={{ ...this.state.purchases }}
        onSubmit={async (values, { setSubmitting, resetForm }) => {
          try {
            if (values.id == 0) {
              await this.props.savePurchases(values);
            } else {
              await this.props.updatePurchases(values);
            }
            resetForm();
            setSubmitting(false);
            this.props.navigation.navigate('PurchasesList');
          } catch (err: any) {
            setSubmitting(false);
            this.props.setMessage('Erro', err.message);
          }
        }}
        enableReinitialize
      >
        {({
          handleChange,
          handleSubmit,
          values,
          errors,
          isSubmitting,
          setValues,
          setFieldValue,
        }) => (
          <ScrollView>
            <View style={styles.container}>
              <TextInput
                mode="outlined"
                style={styles.input}
                label="Id"
                value={values.id === 0 ? '' : values.id.toString()}
                onChangeText={handleChange('id')}
                error={!!errors.id}
                disabled={true}
              />

              {this.props.market.length >= 1 && (
                <AutoComplete
                  label="Mercado"
                  items={this.props.market}
                  onChangeValue={(value: ValueType | ValueType[] | null) => {
                    if (values.marketId != value) {
                      setFieldValue('marketId', value);
                    }
                  }}
                  placeholder="Selecione um mercado"
                  itemValue={values.marketId}
                />
              )}

              <View style={styles.viewCalendar}>
                <TextInput
                  mode="outlined"
                  style={styles.input}
                  label="Data"
                  value={new Date(values.date).toLocaleDateString()}
                  error={!!errors.date}
                  disabled={true}
                  keyboardType="numeric"
                />

                <Icon
                  name="calendar"
                  size={30}
                  style={styles.buttonCalendar}
                  color={DefaultTheme.colors.primary}
                  onPress={() => {
                    this.setState({ ...this.state, dateModal: true });
                  }}
                />
              </View>

              <DatePicker
                modal
                open={this.state.dateModal}
                mode="date"
                title="Seleciona a data"
                date={new Date()}
                confirmText="ok"
                cancelText="Cancelar"
                onConfirm={(date) => {
                  this.setState({ ...this.state, dateModal: false });
                  setFieldValue('date', date);
                }}
                onCancel={() => {
                  this.setState({ ...this.state, dateModal: false });
                }}
              />

              <AutoComplete
                label="Status"
                items={[
                  { id: 1, name: 'Em rota' },
                  { id: 2, name: 'Entregue' },
                ]}
                onChangeValue={(value: ValueType | ValueType[] | null) => {
                  if (values.status != value) {
                    const valueStatus = value == 1 ? 'Em rota' : 'Entregue';
                    if (values.status != valueStatus) {
                      setFieldValue('status', valueStatus);
                    }
                  }
                }}
                placeholder="Selecione o status"
                itemValue={values.status == 'Em rota' ? 1 : 2}
                searchable={false}
              />

              <Formik
                initialValues={{ ...this.state.itemPurchases }}
                onSubmit={async (
                  values,
                  { setSubmitting, resetForm, setValues },
                ) => {
                  let newItemPurchasesList = this.state.itemPurchasesList;

                  if (values.id == 0) {
                    if (newItemPurchasesList.length >= 1) {
                      values.id =
                        newItemPurchasesList[newItemPurchasesList.length - 1]
                          .id + 1;
                    }
                  } else {
                    newItemPurchasesList = newItemPurchasesList.map((item) => {
                      if (item.id == values.id) {
                        item = values;
                      }
                      return item;
                    });
                  }
                  newItemPurchasesList = newItemPurchasesList.concat(values);

                  this.setState({
                    ...this.state,
                    itemPurchasesList: newItemPurchasesList,
                  });
                  setFieldValue(
                    'itemPurchaseDTOList',
                    this.state.itemPurchasesList,
                  );
                  resetForm();
                  setValues({
                    ...initialValuesItem.itemPurchases,
                  });
                  setSubmitting(false);
                  try {
                    if (this.state.purchases.id == 0) {
                      await AsyncStorage.setItem(
                        'PurchasesList',
                        JSON.stringify(this.state.itemPurchasesList),
                      );
                    }
                  } catch (err) {
                    console.log(err);
                  }
                }}
                enableReinitialize
              >
                {({
                  handleChange,
                  handleSubmit,
                  values,
                  errors,
                  isSubmitting,
                  setFieldValue,
                }) => (
                  <View style={styles.containerForm}>
                    {this.props.category.length >= 1 && (
                      <AutoComplete
                        label="Categoria"
                        items={this.props.category}
                        onChangeValue={(
                          value: ValueType | ValueType[] | null,
                        ) => {
                          const productFilter: Product[] =
                            this.props.product.filter((item) => {
                              return item.category.id === value;
                            });
                          if (
                            !!value &&
                            !equals(this.state.productFilter, productFilter)
                          ) {
                            this.setState({ ...this.state, productFilter });
                          }
                        }}
                        placeholder="Selecione uma categoria"
                      />
                    )}
                    {this.props.product.length >= 1 && (
                      <AutoComplete
                        label="Produtos"
                        items={
                          this.state.productFilter.length >= 1
                            ? this.state.productFilter
                            : this.props.product
                        }
                        itemValue={values.productId}
                        onChangeValue={(
                          value: ValueType | ValueType[] | null,
                        ) => {
                          const productSelected = this.props.product.filter(
                            (item) => {
                              return item.id == value;
                            },
                          )[0];
                          if (
                            !!value &&
                            values.productId !== productSelected?.id
                          ) {
                            setFieldValue('productId', value);
                          }
                        }}
                        placeholder="Selecione um produto"
                      />
                    )}

                    <TextInput
                      mode="outlined"
                      keyboardType="numeric"
                      style={styles.input}
                      label="Quantidade"
                      value={
                        values.quantity === 0 ? '' : values.quantity.toString()
                      }
                      onChangeText={handleChange('quantity')}
                      error={!!errors.quantity}
                    />

                    <TextInput
                      keyboardType="numeric"
                      mode="outlined"
                      style={styles.input}
                      label="Preço"
                      value={values.price === 0 ? '' : values.price.toString()}
                      onChangeText={handleChange('price')}
                      error={!!errors.price}
                    />

                    <View style={styles.viewValidaty}>
                      <TouchableOpacity
                        onPress={() => {
                          setFieldValue('validaty', new Date(''));
                        }}
                        style={{ width: '90%', marginTop: 20 }}
                      >
                        <TextInput
                          mode="outlined"
                          label={
                            values.validaty?.toString() != 'Invalid Date' &&
                            values.validaty != null
                              ? 'Validade - Pressione para limpar'
                              : 'Validade'
                          }
                          value={
                            values.validaty?.toDateString() !==
                              'Invalid Date' && values.validaty != null
                              ? new Date(values.validaty).toLocaleDateString()
                              : ''
                          }
                          error={!!errors.validaty}
                          disabled={true}
                        />
                      </TouchableOpacity>
                      <Icon
                        name="calendar"
                        size={30}
                        style={styles.buttonCalendar}
                        color={DefaultTheme.colors.primary}
                        onPress={() => {
                          this.setState({
                            ...this.state,
                            validatyDateModal: true,
                          });
                        }}
                      />
                    </View>

                    <DatePicker
                      modal
                      open={this.state.validatyDateModal}
                      mode="date"
                      title="Seleciona a data"
                      date={new Date()}
                      confirmText="ok"
                      cancelText="Cancelar"
                      onConfirm={(date) => {
                        this.setState({
                          ...this.state,
                          validatyDateModal: false,
                        });
                        setFieldValue('validaty', date);
                      }}
                      onCancel={() => {
                        this.setState({
                          ...this.state,
                          validatyDateModal: false,
                        });
                      }}
                    />

                    <Button
                      onPress={handleSubmit}
                      mode="contained"
                      style={styles.button}
                      disabled={isSubmitting}
                    >
                      Adicionar produto
                    </Button>
                  </View>
                )}
              </Formik>

              {this.state.itemPurchasesList.map((item, index) => {
                return (
                  <View key={index}>
                    <View style={styles.viewPurchasesList}>
                      <View style={styles.descriptionItemPurchases}>
                        <Text>Id: {item.id}</Text>
                        {!!this.props.product && (
                          <Text>
                            Produto:
                            {item.productId != 0
                              ? this.props.product.filter((product) => {
                                  return product.id == item.productId;
                                })[0].name
                              : ''}
                          </Text>
                        )}
                        <Text>
                          Quantidade:
                          {' ' + item.quantity.toString().replace('.', ',')}
                        </Text>
                        <Text>Preço: {formatMoney(item.price)}</Text>
                        <Text>
                          Total: {totalFormat(item.price, item.quantity)}
                        </Text>
                        <Text>
                          {item.validaty?.toString() != 'Invalid Date' &&
                          item.validaty != null
                            ? 'Validade: ' +
                              new Date(item.validaty).toLocaleDateString()
                            : ''}
                        </Text>
                      </View>

                      <View style={styles.viewButton}>
                        <Icon
                          name="edit"
                          size={30}
                          style={styles.buttonCalendar}
                          color={DefaultTheme.colors.primary}
                          onPress={() => {
                            if (this.state.itemPurchases.id != item.id) {
                              this.setState({
                                ...this.state,
                                itemPurchases: item,
                              });
                            }
                            console.log('item');
                          }}
                        />
                        <Icon
                          name="delete"
                          size={30}
                          style={styles.buttonCalendar}
                          color={DefaultTheme.colors.primary}
                          onPress={() => {
                            let newItemPurchasesList =
                              this.state.itemPurchasesList;
                            newItemPurchasesList = newItemPurchasesList.filter(
                              (itemPurchases) => {
                                return itemPurchases.id != item.id;
                              },
                            );
                            this.setState({
                              ...this.state,
                              itemPurchasesList: newItemPurchasesList,
                            });
                            setFieldValue(
                              'itemPurchaseDTOList',
                              this.state.itemPurchasesList,
                            );
                            if (values.id == 0) {
                              AsyncStorage.setItem(
                                'PurchasesList',
                                JSON.stringify(newItemPurchasesList),
                              );
                            }
                          }}
                        />
                      </View>
                    </View>
                    <Text
                      style={{
                        height: 1,
                        borderBottomColor: '#91a3b0',
                        borderBottomWidth: 1,
                        width: '90%',
                      }}
                    ></Text>
                  </View>
                );
              })}

              <View style={styles.viewButton}>
                <Button
                  onPress={handleSubmit}
                  mode="contained"
                  style={styles.button}
                  disabled={isSubmitting}
                >
                  Enviar
                </Button>
                <Button
                  onPress={() => {
                    setValues(initialValues.purchases);
                    AsyncStorage.removeItem('PurchasesList');
                    this.setState({
                      ...this.state,
                      ...initialValues,
                      ...initialValuesItem,
                    });
                    this.props.navigation.dispatch(
                      CommonActions.reset({
                        index: 0,
                        routes: [
                          {
                            name: 'PurchasesForm',
                          },
                        ],
                      }),
                    );
                  }}
                  mode="contained"
                  style={styles.button}
                >
                  Limpar
                </Button>
              </View>
            </View>
          </ScrollView>
        )}
      </Formik>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
  },
  containerForm: {
    width: '100%',
    alignItems: 'center',
  },
  input: {
    marginTop: 20,
    width: '90%',
  },
  button: {
    marginTop: 20,
    marginLeft: 5,
  },
  viewButton: {
    flexDirection: 'row',
    marginBottom: 20,
  },
  viewCalendar: {
    flexDirection: 'row',
    width: '90%',
    alignItems: 'center',
  },
  buttonCalendar: {
    marginTop: 20,
    marginStart: 10,
  },
  viewValidaty: {
    flexDirection: 'row',
    width: '90%',
    alignItems: 'center',
  },
  viewPurchasesList: {
    width: '90%',
    flexDirection: 'row',
    alignItems: 'center',
  },
  descriptionItemPurchases: { width: '80%' },
});

const purchasesToPurchasesDTO = (purchases: Purchases) => {
  const newItemList = [] as itemPurchaseDTO[];
  purchases.itemPurchaseList.forEach((item) => {
    const itemPurchasesDTO: itemPurchaseDTO = {
      id: item.id,
      quantity: item.quantity,
      validaty: item.validaty,
      price: item.price,
      productId: item.stock.product.id,
    };
    newItemList.push(itemPurchasesDTO);
  });

  const purchasesDto: PurchasesDTO = {
    id: purchases.id,
    marketId: purchases.market.id,
    date: purchases.date,
    status: purchases.status,
    itemPurchaseDTOList: newItemList,
  };
  return purchasesDto;
};

const equals = (a: any, b: any) =>
  a.length === b.length && a.every((v: any, i: any) => v === b[i]);

const mapStateToProps = ({ market, category, product }: any) => {
  return {
    market: market.market as Market[],
    product: product.product as Product[],
    category: category.category as Category[],
  };
};

const mapDispatchToProps = (dispatch: any) => {
  return {
    setMessage: (title: string, text: string) =>
      dispatch(setMessage({ title, text })),
    loadAllMarket: () => dispatch(LoadAllMarket()),
    loadAllCategory: () => dispatch(LoadAllCategory()),
    loadAllProduct: () => dispatch(LoadAllProduct()),
    savePurchases: (purchases: PurchasesDTO) =>
      dispatch(SavePurchases(purchases)),
    updatePurchases: (purchases: PurchasesDTO) =>
      dispatch(UpdatePurchases(purchases)),
  };
};

const connector = connect(mapStateToProps, mapDispatchToProps);
type PropsFromRedux = ConnectedProps<typeof connector>;
export default connector(PurchasesForm);
