/* eslint-disable @typescript-eslint/no-explicit-any */
import React, { Component } from 'react';
import { Formik } from 'formik';
import { itemPurchaseDTO } from '../../../app/models/purchasesDTO';
import { Category } from '../../../app/models/category';
import { setMessage } from '../../../store/actions/message';
import { LoadAllCategory } from '../../../store/actions/category';
import { connect, ConnectedProps } from 'react-redux';
import { View, TouchableOpacity } from 'react-native';
import { TextInput, Button, DefaultTheme } from 'react-native-paper';
import { Product } from '../../../app/models/product';

interface Props extends PropsFromRedux {
  navigation: {
    navigate: any;
    toggleDrawer: any;
    closeDrawer: any;
    openDrawer: any;
    dispatch: any;
  };
  route: {
    params: any;
  };
  itemPurchasesSelected: itemPurchaseDTO;
  product: Product[];
}

class PurchasesForm extends Component<Props> {
  state = {
    validatyDateModal: false,
  };

  render() {
    return (
      <Formik
        initialValues={this.props.itemPurchasesSelected}
        onSubmit={async (values, { setSubmitting, resetForm, setValues }) => {
          let newItemPurchasesList = this.state.purchases.itemPurchaseDTOList;
          if (values.id == 0) {
            if (newItemPurchasesList.length >= 1) {
              values.id =
                newItemPurchasesList[newItemPurchasesList.length - 1].id + 1;
            } else {
              values.id = 1;
            }
            newItemPurchasesList = newItemPurchasesList.concat(values);
          } else {
            newItemPurchasesList.forEach((item) => {
              if (item.id == values.id) {
                item = values;
              }
            });
          }
          this.setState({
            ...this.state,
            purchases: {
              ...this.state.purchases,
              itemPurchaseDTOList: newItemPurchasesList,
            },
            itemPurchasesSelected: initialValuesItem.itemPurchases,
          });
          setFieldValue(
            'itemPurchaseDTOList',
            this.state.purchases.itemPurchaseDTOList,
          );
          if (this.state.purchases.id == 0) {
            try {
              if (this.state.purchases.id == 0) {
                await AsyncStorage.setItem(
                  'PurchasesList',
                  JSON.stringify(this.state.purchases.itemPurchaseDTOList),
                );
              }
            } catch (err) {
              console.log(err);
            }
          }
          resetForm();
          setValues({
            ...initialValuesItem.itemPurchases,
          });
          setSubmitting(false);
        }}
        enableReinitialize
      >
        {({
          handleChange,
          handleSubmit,
          values,
          errors,
          isSubmitting,
          setFieldValue,
        }) => (
          <View style={styles.containerForm}>
            {this.props.category.length >= 1 && (
              <AutoComplete
                label="Categoria"
                items={this.props.category}
                onChangeValue={(value: ValueType | ValueType[] | null) => {
                  const productFilter: Product[] = this.props.product.filter(
                    (item) => {
                      return item.category.id === value;
                    },
                  );
                  if (
                    !!value &&
                    !equals(this.state.productFilter, productFilter)
                  ) {
                    this.setState({ ...this.state, productFilter });
                  }
                }}
                placeholder="Selecione uma categoria"
              />
            )}
            {this.props.product.length >= 1 && (
              <AutoComplete
                label="Produtos"
                items={
                  this.state.productFilter.length >= 1
                    ? this.state.productFilter
                    : this.props.product
                }
                itemValue={values.productId}
                onChangeValue={(value: ValueType | ValueType[] | null) => {
                  const productSelected = this.props.product.filter((item) => {
                    return item.id == value;
                  })[0];
                  if (!!value && values.productId !== productSelected?.id) {
                    setFieldValue('productId', value);
                  }
                }}
                placeholder="Selecione um produto"
              />
            )}

            <TextInput
              mode="outlined"
              keyboardType="numeric"
              style={styles.input}
              label="Quantidade"
              value={values.quantity === 0 ? '' : values.quantity.toString()}
              onChangeText={handleChange('quantity')}
              error={!!errors.quantity}
            />

            <TextInput
              keyboardType="numeric"
              mode="outlined"
              style={styles.input}
              label="PreÃ§o"
              value={values.price === 0 ? '' : values.price.toString()}
              onChangeText={handleChange('price')}
              error={!!errors.price}
            />

            <View style={styles.viewValidaty}>
              <TouchableOpacity
                onPress={() => {
                  setFieldValue('validaty', new Date(''));
                }}
                style={{ width: '90%', marginTop: 20 }}
              >
                <TextInput
                  mode="outlined"
                  label={
                    values.validaty?.toString() != 'Invalid Date' &&
                    values.validaty != null
                      ? 'Validade - Pressione para limpar'
                      : 'Validade'
                  }
                  value={
                    values.validaty?.toDateString() !== 'Invalid Date' &&
                    values.validaty != null
                      ? new Date(values.validaty).toLocaleDateString()
                      : ''
                  }
                  error={!!errors.validaty}
                  disabled={true}
                />
              </TouchableOpacity>
              <Icon
                name="calendar"
                size={30}
                style={styles.buttonCalendar}
                color={DefaultTheme.colors.primary}
                onPress={() => {
                  this.setState({
                    ...this.state,
                    validatyDateModal: true,
                  });
                }}
              />
            </View>
            {console.log(values)}
            <DatePicker
              modal
              open={this.state.validatyDateModal}
              mode="date"
              title="Seleciona a data"
              date={new Date()}
              confirmText="ok"
              cancelText="Cancelar"
              onConfirm={(date) => {
                this.setState({
                  ...this.state,
                  validatyDateModal: false,
                });
                setFieldValue('validaty', date);
              }}
              onCancel={() => {
                this.setState({
                  ...this.state,
                  validatyDateModal: false,
                });
              }}
            />
            <View style={styles.viewButton}>
              <Button
                onPress={handleSubmit}
                mode="contained"
                style={styles.button}
                disabled={isSubmitting}
              >
                {values.id > 0 ? 'Editar produto' : 'Adicionar produto'}
              </Button>
              {values.id > 0 && (
                <Button
                  onPress={() => {
                    this.setState({
                      ...this.state,
                      itemPurchasesSelected: initialValuesItem.itemPurchases,
                    });
                  }}
                  mode="contained"
                  style={styles.button}
                  disabled={isSubmitting}
                >
                  Limpar
                </Button>
              )}
            </View>
          </View>
        )}
      </Formik>
    );
  }
}

const mapStateToProps = ({ market, category, product }: any) => {
  return {
    category: category.category as Category[],
  };
};

const mapDispatchToProps = (dispatch: any) => {
  return {
    setMessage: (title: string, text: string) =>
      dispatch(setMessage({ title, text })),
    loadAllCategory: () => dispatch(LoadAllCategory()),
  };
};

const connector = connect(mapStateToProps, mapDispatchToProps);
type PropsFromRedux = ConnectedProps<typeof connector>;
export default connector(PurchasesForm);
